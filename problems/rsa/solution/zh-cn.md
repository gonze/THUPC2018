{{ self.title() }}

n+e

## 题目简述

RSA加密算法中，如果选择相同模数 $N$， 不同私钥 $e_1$，$e_2$进行加密，得到密文 $c_1$，$c_2$，将原文 $m$ 反解。
$$
\begin{matrix}c_1&=&m^{e_1}\bmod N\\c_2&=&m^{e_2}\bmod N\end{matrix}
$$

## 算法1：暴破RSA

本来打算数据范围出到 $N<2^{1024}$，但是王队长说不要给 C++ 选手强行增加高精度难度，于是就把范围改成了 $N<2^{63}$。如果有可能的话，可以用 Miller-Rabin 算法来爆破，解出私钥之后即可。出题人表示并没有试过。

虽然还是要写高精度是吧……两个long long的。py大法好

## 算法2：推式子

由于 $e_1$，$e_2$ 互质，因此可写为
$$
e_1s+e_2t=1
$$
其中 $s$，$t$ 为整数，一正一负。我们所要求的东西是 $m\bmod N$，可以写为 $m^{1}\bmod N$，即 $m^{e_1s+e_2t}\bmod N$，再化简一下就是 $(m^{e_1})^s(m^{e_2})^t\bmod N$，即为 $c_1^sc_2^t\bmod N$。因此只要求出 $s$ 和 $t$ 之后就能得到答案，解法和RSA没太大关系。

$s$ 和 $t$ 可以用exgcd (拓展欧几里得算法) 求出，注意求出的 $s$ 和 $t$ 是一正一负，不妨假设 $s$ 是负数。按照常规的方法，$c_1^{-|s|}\bmod N=c_1^{\varphi{(N)}-|s|}\bmod N$，然而求 $\varphi{(N)}$ 的难度相当于质因数分解，因此不能这么做。

注意到 $c_1^{-|s|}\bmod N=(c_1^{-1})^{|s|}\bmod N$，因此只需求出 $c_1^{-1}\bmod N$ 即可。假设 $d=c_1^{-1}\bmod N$， 那么 $c_1d+kN=1$，再用exgcd即可得到 $d$ 的值。这样求完 $s$，$t$，$c_1^s$ 和 $c_2^t$ 之后输出乘积即可通过。



